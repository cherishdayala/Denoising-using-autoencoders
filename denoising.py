# Importing all the required libraries
import numpy as np
import pandas as pd
import os
import keras
from keras import optimizers
from keras.preprocessing import image
import matplotlib.pyplot as plt
from keras.models import Sequential, Model
from keras.layers import Dense, Conv2D, MaxPooling2D,MaxPool2D ,UpSampling2D, Flatten, Input
from keras import backend as K
import tensorflow as tf
from tensorflow.keras.callbacks import EarlyStopping
import cv2
from math import log10,sqrt

# Mounting the dataset from the Google Drive
from google.colab import drive
drive.mount('/content/gdrive')

# Function to convert images to numpy array of image-array
# Input : Images
# Output : Return numpy array of images array
def convert_image_to_array(train_images):
  image_list = []
  for img in train_images:
    t_img = image.load_img('gdrive/My Drive/CT_COVID/' + img, target_size=(64,64),color_mode='grayscale')
    img_arr = (image.img_to_array(t_img))/255
    image_list.append(img_arr)
  
  return np.array(image_list)

# Input dataset from gdrive
train_images=sorted(os.listdir('gdrive/My Drive/CT_COVID/'))

# Converting images to numpy image array
train_image_data = convert_image_to_array(train_images)
print(train_image_data)

# Function to plot the images
def plot_images(image_dataset):
  
  # Drawing multiple plots
  f,ax=plt.subplots(1,5)
  f.set_size_inches(40,20)
  for i in range(5,10):
    ax[i-5].imshow(image_dataset[i].reshape(64,64), cmap='gray')
  plt.show()

# Plotting the train images
plot_images(train_image_data)

# Adding gaussian noise with 0.05 factor
# Funtion returns array to drawn samples from the parameterized normal distribution.
def add_noise(image):
  row,col,ch=image.shape

  # Mean (“centre”) of the distribution.
  mean=0

  # Standard deviation (spread or “width”) of the distribution
  sigma=1

  # Drawing random samples from a normal (Gaussian) distribution with given mean, sd, and Output shape.
  gauss=np.random.normal(mean,sigma,(row,col,ch))
  gauss=gauss.reshape(row,col,ch)

  # Adding Gaussian noise to image
  noisy=image+gauss*0.05
  return noisy

noised_images=[]
for img in train_image_data:
  noisy=add_noise(img)
  noised_images.append(noisy)

noised_images=np.array(noised_images)
# Plotting the noised images
plot_images(noised_images)

# Splitting the testing data
xnoised=noised_images[:300]
xtest=noised_images[300:]


# Function for Autoencoders
def autoencoder():
  input_img=Input(shape=(64,64,1),name='image_input')

  #encoder - compresses the original input into a small encoding
  x = Conv2D(64, (3,3), activation='relu', padding='same', name='Conv1')(input_img)
  x = MaxPooling2D((2,2), padding='same', name='pool1')(x)
  x = Conv2D(64, (3,3), activation='relu', padding='same', name='Conv2')(x)
  x = MaxPooling2D((2,2), padding='same', name='pool2')(x)
   
  #decoder - restores the original data from that encoding generated by the Encoder
  x = Conv2D(64, (3,3), activation='relu', padding='same', name='Conv3')(x)
  x = UpSampling2D((2,2), name='upsample1')(x)
  x = Conv2D(64, (3,3), activation='relu', padding='same', name='Conv4')(x)
  x = UpSampling2D((2,2), name='upsample2')(x)
  x = Conv2D(1, (3,3), activation='sigmoid', padding='same', name='Conv5')(x)
   
  autoencoder = Model(inputs=input_img, outputs=x)
  autoencoder.compile(optimizer='adam', loss='binary_crossentropy')
    
  return autoencoder


# Summarizing the statistics
model= autoencoder()
model.summary()

# Regularizing to avoid overfitting of the data
with tf.device('/device:GPU:0'):
    early_stopping = EarlyStopping(monitor='val_loss', min_delta=0, patience=10, verbose=1, mode='auto')
    model.fit(xnoised, xnoised, epochs=18, batch_size=10, validation_data=(xtest, xtest), callbacks=[early_stopping])

    
# function to plot the preditions
def plot_predictions(x_train, y_true, y_pred):    
    f, ax = plt.subplots(4, 5)
    f.set_size_inches(10.5,7.5)
    for i in range(5):
        ax[0][i].imshow(np.reshape(xtrain[i], (64,64)), aspect='auto', cmap='gray')
        ax[1][i].imshow(np.reshape(y_true[i], (64,64)), aspect='auto', cmap='gray')
        ax[2][i].imshow(np.reshape(y_pred[i], (64,64)), aspect='auto', cmap='gray')
        ax[3][i].imshow(cv2.medianBlur(xtrain[i], (5)), aspect='auto', cmap='gray')
    
    # adjusting subplot params so that the subplot fits in to the figure area
    plt.tight_layout()

# training data
xtrain= train_image_data[200:]

# predicted data
pred= model.predict(xtest[:5])

# Plotting the predictions
plot_predictions(xtrain, xtest[:5], pred[:5])

# replacing the central element of the image by the median of all the pixels in the kernel area
median_blur = cv2.medianBlur(xtrain[0], (5))

# blurring by using gaussian function
gaussian_blur=cv2.GaussianBlur(xtrain[0],(5,5),0)

# blurring the image using  normalized box filter
average_blur=cv2.blur(xtrain[0],(5,5))

# Smoothening the image while preserving edges using bilateral filter
bilateral_filter=cv2.bilateralFilter(xtrain[0],9,75,75)

# Plotting the images
f,ax=plt.subplots(1,5)
f.set_size_inches(40,20)
ax[0].imshow(pred[0].reshape(64,64), cmap='gray')
ax[0].set_title('Autoencoder Image')
ax[1].imshow(median_blur,cmap='gray')
ax[1].set_title('Median Filter')
ax[2].imshow(gaussian_blur,cmap='gray')
ax[2].set_title('Gaussian Filter')
ax[3].imshow(average_blur,cmap='gray')
ax[3].set_title('Average Filter')
ax[4].imshow(bilateral_filter,cmap='gray')
ax[4].set_title('Bilateral Filter')

# function to compute the peak signal-to-noise ratio values for different filters
def PSNR(original, denoised): 
    mse = np.mean((original - denoised) ** 2) 
    if(mse == 0): 
        return 100
    max_pixel = 255.0
    psnr = 20 * log10(max_pixel / sqrt(mse)) 
    return psnr 

  
value1 = PSNR(xtest[0], median_blur)
value2 = PSNR(xtest[0], pred[0])
value3 = PSNR(xtest[0], gaussian_blur)
value4 = PSNR(xtest[0], average_blur)
value5 = PSNR(xtest[0], bilateral_filter)

print("PSNR values")
print(f"Autoencoder Image : {value2} dB")
print(f"Median Filter Image : {value1} dB")
print(f"Gaussian Filter Image : {value3} dB")
print(f"Average Filter Image : {value4} dB")
print(f"Bilateral Filter Image : {value5} dB")
